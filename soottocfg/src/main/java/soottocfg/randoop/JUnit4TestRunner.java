package soottocfg.randoop;

import junit.framework.AssertionFailedError;

import javax.annotation.Nonnull;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.atomic.AtomicReference;

/**
 * @author Huascar Sanchez
 */
public class JUnit4TestRunner implements TestRunner {
  private final ExecutionLog log;
  private final Class<?> testClass;
  private final int timeoutSeconds;

  private static final int ESTIMATED_DURATION_PER_TEST_IN_SECS = 10;

  private final ExecutorService executor = Executors
    .newCachedThreadPool(daemonThreadFactory("testrunner"));

  /**
   * Construct a JUnit 4 test runner.
   * @param testClass Test class
   */
  public JUnit4TestRunner(Class<?> testClass){
    this(new BasicExecutionLog(System.out), testClass, ESTIMATED_DURATION_PER_TEST_IN_SECS);
  }

  /**
   * Construct a JUnit 4 test runner.
   *
   * @param log monitors execution of JUnit4 Runner.
   * @param testClass Test class
   * @param timeoutSeconds test execution timeout.
   */
  public JUnit4TestRunner(ExecutionLog log, Class<?> testClass, int timeoutSeconds){
    this.log            = log;
    this.testClass      = testClass;
    this.timeoutSeconds = timeoutSeconds;
  }

  /**
   * Execute the unit tests of a test class generated by {@link Randoop}.
   *
   * @param testClass test class to execute.
   * @param args the arguments for the test.
   * @return true if the tests were executed.
   */
  public static boolean runUnitTests(Class<?> testClass, String... args){
    return new JUnit4TestRunner(testClass).run(args);
  }

  @Override public boolean isClassSupported(Class<?> klass) {
    return JUnit4TestMaker.isJunit4Test(klass);
  }

  @Override public boolean run(String... args) {

    if(!isClassSupported(testClass)) {
      throw new IllegalStateException("Not a JUnit4 test class.");
    }

    final List<UnitTest> tests;

    if(JUnit4TestMaker.isJunit4Test(testClass)){
      tests = JUnit4TestMaker.makeUnitTests(testClass, args);
    } else {
      throw new AssertionFailedError("Unknown JUnit type: " + testClass.getName());
    }

    for(UnitTest eachTest : tests){
      runWithTimeout(eachTest);
    }

    return true;
  }

  private void runWithTimeout(UnitTest test){

    log.info("Starting test " + test);

    // Start the test on a background thread.
    final AtomicReference<Thread> executingThreadReference = new AtomicReference<>();

    final Future<Throwable> result = executor.submit(new ExecuteTest(test, executingThreadReference));

    // Wait until either the result arrives or the test times out.
    Throwable thrown;
    try {
      // disabling intention. Reason: intended behavior
      //noinspection ThrowableResultOfMethodCallIgnored
      thrown = timeoutSeconds == 0
        ? result.get()
        : result.get(timeoutSeconds, TimeUnit.SECONDS);
    } catch (TimeoutException e){
      Thread executingThread = executingThreadReference.get();

      if (executingThread != null) {
        executingThread.interrupt();
        e.setStackTrace(executingThread.getStackTrace());
      }

      thrown = e;

    } catch (Exception e) {
      thrown = e;
    }

    if (thrown != null) {
      log.error("EXECUTION FAILED ", thrown);
    } else {
      log.info("SUCCESS");
    }
  }

  static ThreadFactory daemonThreadFactory(final String name) {
    return new ThreadFactory() {
      private int nextId = 0;

      @Override public synchronized Thread newThread(@Nonnull Runnable runnable) {
        Thread thread = new Thread(runnable, name + "-" + (nextId++));
        thread.setDaemon(true);
        return thread;
      }
    };
  }

  static class ExecuteTest implements Callable<Throwable> {
    private final UnitTest test;
    private final AtomicReference<Thread> executingThreadReference;

    ExecuteTest(UnitTest test, AtomicReference<Thread> executingThreadReference){
      this.test = test;
      this.executingThreadReference = executingThreadReference;
    }

    @Override public Throwable call() throws Exception {
      executingThreadReference.set(Thread.currentThread());
      try {
        test.run();
        return null;
      } catch (Throwable throwable) {
        return throwable;
      }
    }
  }


}
