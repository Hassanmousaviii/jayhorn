/**
 * 
 */
package soottocfg.test.translation_test;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.Collection;
import java.util.LinkedList;
import java.util.List;

import org.junit.Assert;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;

import com.google.common.io.Files;

import soot.Scene;
import soot.SootClass;
import soot.SourceLocator;
import soot.jimple.JasminClass;
import soot.options.Options;
import soot.util.JasminOutputStream;
import soottocfg.soot.SootToCfg;
import soottocfg.soot.util.SootTranslationHelpers;
import soottocfg.test.Util;

/**
 * @author schaef
 *
 */
@RunWith(Parameterized.class)
public class DynamicTest {

	private static final String userDir = System.getProperty("user.dir") + "/";
	private static final String testRoot = userDir + "src/test/resources/";

	private File sourceFile;
	
	@Parameterized.Parameters(name = "{index}: check ({1})")
	public static Collection<Object[]> data() {
		List<Object[]> filenames = new LinkedList<Object[]>();
		final File source_dir = new File(testRoot + "dynamic_tests/");
		File[] directoryListing = source_dir.listFiles();
		if (directoryListing != null) {
			for (File child : directoryListing) {
				if (child.isFile() && child.getName().endsWith(".java")) {
					filenames.add(new Object[] { child, child.getName() });
				} else {
					// Ignore
				}
			}
		} else {
			// Handle the case where dir is not really a directory.
			// Checking dir.isDirectory() above would not be sufficient
			// to avoid race conditions with another process that deletes
			// directories.
			System.err.println("Test data in " + userDir + " not found");
			throw new RuntimeException("Test data not found!");
		}
		return filenames;
	}

	public DynamicTest(File source, String name) {
		this.sourceFile = source;
	}

	@Test
	public void test() throws Throwable {
		soot.G.reset();
		File classDir = null;
		try {
			classDir = Util.compileJavaFile(this.sourceFile);
		} catch (IOException e) {
			e.printStackTrace();
			Assert.fail();
		}
		if (classDir == null) {
			Assert.fail();
		}
		Assert.assertTrue(classDir.isDirectory());
		// Now we have the classDir of the original program

		File transformedClassDir = Files.createTempDir();
		SootToCfg soot2cfg = new SootToCfg();
		soot2cfg.runPreservingTransformationOnly(classDir.getAbsolutePath(), null);

		// write out the transformed classes
		for (SootClass sc : Scene.v().getApplicationClasses()) {
			writeClassToFile(sc, transformedClassDir);
		}

		Class<?> cOrig = loadClass(classDir);
		// load the assertion class
		try (URLClassLoader classLoader = new URLClassLoader(new URL[] { transformedClassDir.toURI().toURL() });) {
			classLoader.loadClass(SootTranslationHelpers.v().getAssertionClass().getName());
			Class<?> cNew = classLoader.loadClass(cOrig.getName());
			Assert.assertTrue(compareClassFiles(cOrig, cNew));
		} catch (Throwable e) {
			throw e;
		}

//		Class<?> cNew = loadClass(transformedClassDir);
		
	}

	private boolean compareClassFiles(Class<?> c1, Class<?> c2) {
		for (Method m1 : c1.getDeclaredMethods()) {
			if ("$jacocoInit".equals(m1.getName())) {
				// This is generated by our CI, ignore it.
				continue;
			}
			try {
				Method m2 = c2.getDeclaredMethod(m1.getName(), m1.getParameterTypes());
				System.out.print("Testing " + m1.getName() + ": ");
				if (m1.getReturnType().equals(Void.TYPE)) {
					System.out.println(" returns void. Skipping");
					continue;
				}
				if (m1.getParameterTypes().length != 0) {
					System.out.println(" only testing Methods for 0 params. Skipping");
					continue;
				}

				if (!compareMethodsWithoutParameters(c1, m1, c2, m2)) {
					System.out.println(" output different :(");
					return false;
				}

				System.out.println(" all good :) ");
			} catch (NoSuchMethodException | SecurityException e) {
				e.printStackTrace();
				return false;
				// } catch (VerifyError e) {
				// System.err.println("WARNING: For whatever reason this test
				// only runs from within eclipse");
				// e.printStackTrace();
				// return true;
			}
		}
		return true;
	}

	private boolean compareMethodsWithoutParameters(Class<?> c1, Method m1, Class<?> c2, Method m2) {
		Object out1 = null;
		try {
			out1 = m1.invoke(c1.newInstance());
		} catch (InvocationTargetException e) {
			// if m1 throws an exception, use that as return value.
			// Convert the exception into a string, otherwise we
			// cannot compare it to the exception thrown by m2
			out1 = e.getTargetException().toString();
		} catch (Throwable e) {
			e.printStackTrace();
			return true;
		}

		Object out2 = null;
		try {
			out2 = m2.invoke(c2.newInstance());
		} catch (InvocationTargetException e) {
			// if m2 throws an exception, use that as return value.
			// Convert the exception into a string, otherwise we
			// cannot compare it to the exception thrown by m1
			out2 = e.getTargetException().toString();
		} catch (Throwable e) {
			e.printStackTrace();
			return true;
		}

		if (out1 == null) {
			if (out2 == null) {
				System.out.println("Output: both null");
				return true;
			}
			StringBuilder sb = new StringBuilder();
			sb.append("Output: ");
			sb.append("null is not equals to ");
			sb.append(out2);
			System.out.println(sb.toString());
			return false;
		} else {
			if (!out1.equals(out2)) {
				StringBuilder sb = new StringBuilder();
				sb.append("For " + m1.getName());
				sb.append("\nOutput different: ");
				sb.append(out1);
				sb.append(" is different from ");
				sb.append(out2);
				System.out.println(sb.toString());
				return false;
			}

			StringBuilder sb = new StringBuilder();
			sb.append("Output: ");
			sb.append(out1);
			sb.append(" is equals to ");
			sb.append(out2);
			System.out.println(sb.toString());
			return true;
		}
	}

	private Class<?> loadClass(File classDir) throws Throwable {
		StringBuilder sb = new StringBuilder();
		File dir = classDir;
		while (dir.isDirectory()) {
			if (dir.listFiles() != null && dir.listFiles().length>0) {
				dir = dir.listFiles()[0];
				sb.append(Files.getNameWithoutExtension(dir.getAbsolutePath()));
				if (dir.isFile() && "class".equals(Files.getFileExtension(dir.getAbsolutePath()))) {
					if (Files.getNameWithoutExtension(dir.getAbsolutePath())
							.equals(SootTranslationHelpers.v().getAssertionClass().getName())) {
						// don't load the assertion class
					} else {
						break;
					}
				} else {
					sb.append(".");
				}
			}
		}
		String className = sb.toString();

		try (URLClassLoader classLoader = new URLClassLoader(new URL[] { classDir.toURI().toURL() });) {
			return classLoader.loadClass(className);
		} catch (Throwable e) {
			throw e;
		}
	}

	private void writeClassToFile(SootClass sClass, File dir) {
		sClass.validate();

		String currentName = SourceLocator.v().getFileNameFor(sClass, Options.output_format_class);

		StringBuilder sb = new StringBuilder();
		sb.append(dir.getAbsolutePath());
		sb.append(File.separator);
		if (!sClass.getPackageName().isEmpty()) {
			sb.append(sClass.getPackageName().replace(".", File.separator));
			sb.append(File.separator);
		}
		sb.append(Files.getNameWithoutExtension(currentName));
		sb.append(".class");
		File modifiedClassFile = new File(sb.toString());
		if (!modifiedClassFile.getParentFile().mkdirs()) {
			// no folders needed
		}
		String fileName = modifiedClassFile.getAbsolutePath();

		// write the class to a file
		try (OutputStream streamOut = new JasminOutputStream(new FileOutputStream(fileName));
				PrintWriter writerOut = new PrintWriter(new OutputStreamWriter(streamOut, "UTF-8"));) {
			JasminClass jasminClass = new JasminClass(sClass);
			jasminClass.print(writerOut);
			writerOut.flush();
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

}
